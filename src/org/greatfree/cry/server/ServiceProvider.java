package org.greatfree.cry.server;

import java.io.IOException;
import java.security.InvalidAlgorithmParameterException;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.security.PrivateKey;
import java.security.PublicKey;
import java.security.SignatureException;
import java.util.Calendar;
import java.util.Collection;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.logging.Logger;

import javax.crypto.BadPaddingException;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.ShortBufferException;

import org.greatfree.cry.SymmetricCrypto;
import org.greatfree.cry.exceptions.CheatingException;
import org.greatfree.cry.exceptions.MachineNotOwnedException;
import org.greatfree.cry.exceptions.NonPrivateMachineException;
import org.greatfree.cry.exceptions.NonPublicMachineException;
import org.greatfree.cry.exceptions.OwnerCheatingException;
import org.greatfree.cry.exceptions.PublicKeyUnavailableException;
import org.greatfree.cry.exceptions.SessionMismatchedException;
import org.bouncycastle.util.encoders.Hex;
import org.greatfree.cry.AsymCompCrypto;
import org.greatfree.cry.AsymmetricCoder;
import org.greatfree.cry.AsymmetricCrypto;
import org.greatfree.cry.PublicCrypto;
import org.greatfree.cry.SymmetricCoder;
import org.greatfree.cry.messege.PublicCryptoSessionRequest;
import org.greatfree.cry.messege.PublicCryptoSessionResponse;
import org.greatfree.cry.messege.SayAsymmetricByeNotification;
import org.greatfree.cry.messege.SaySymmetricByeNotification;
import org.greatfree.cry.messege.SignedAsymmetricEncryptedNotification;
import org.greatfree.cry.messege.SignedAsymmetricEncryptedRequest;
import org.greatfree.cry.messege.SignedAsymmetricEncryptedResponse;
import org.greatfree.cry.messege.SignedPrimitiveNotification;
import org.greatfree.cry.messege.SymmetricBye;
import org.greatfree.cry.messege.AllOwners;
import org.greatfree.cry.messege.AsymmetricBye;
import org.greatfree.cry.messege.AsymmetricEncryptedNotification;
import org.greatfree.cry.messege.AsymmetricEncryptedRequest;
import org.greatfree.cry.messege.AsymmetricEncryptedResponse;
import org.greatfree.cry.messege.AsymmetricPrimitiveNotification;
import org.greatfree.cry.messege.CryAppID;
import org.greatfree.cry.messege.SymmetricCryptoSessionRequest;
import org.greatfree.cry.messege.SymmetricCryptoSessionResponse;
import org.greatfree.cry.messege.SymmetricPrimitiveNotification;
import org.greatfree.cry.multicast.MulticastTask;
import org.greatfree.cry.messege.EncryptedNotification;
import org.greatfree.cry.messege.EncryptedRequest;
import org.greatfree.cry.messege.EncryptedResponse;
import org.greatfree.cry.messege.OwnerJoinNotification;
import org.greatfree.cry.messege.OwnerLeaveNotification;
import org.greatfree.cry.messege.OwnerInfo;
import org.greatfree.cry.messege.OwnershipRequest;
import org.greatfree.cry.messege.OwnershipResponse;
import org.greatfree.cry.messege.PrivateNotification;
import org.greatfree.cry.messege.PrivatePrimitiveNotification;
import org.greatfree.cry.messege.PrivateRequest;
import org.greatfree.cry.messege.PrivateResponse;
import org.greatfree.message.ServerMessage;
import org.greatfree.message.container.Notification;
import org.greatfree.message.container.Request;
import org.greatfree.message.multicast.MulticastMessageType;
import org.greatfree.message.multicast.MulticastNotification;
import org.greatfree.message.multicast.MulticastRequest;
import org.greatfree.message.multicast.MulticastResponse;
import org.greatfree.server.container.PeerContainer;
import org.greatfree.server.container.ServerTask;
import org.greatfree.util.IPAddress;

/**
 * 
 * @author libing
 * 
 *         01/04/2022, Bing Li
 *
 */
public final class ServiceProvider
{
	private final static Logger log = Logger.getLogger("org.greatfree.cry.server");

	private String hostPeerName;
	/*
	 * With the structure, the IP address can be retrieved by the partner's name. 04/14/2022, Bing Li
	 */
	private Map<String, IPAddress> ips;
	/*
	 * With the structure, the partner's name can be retrieved by the IP key. 04/14/2022, Bing Li
	 */
	private Map<String, String> ipPeers;
	
	private Map<String, ServerTask> tasks;
//	private Map<String, MulticastTask> tasks;

	private Map<String, SymmetricCrypto> symmetricCryptos;

	private AsymmetricCrypto asymCrypto;
	// The public keys are generated by remote partners. Using them, the messages to those partners can be encrypted. The key of the map is the session key of the AsymmetricCrypto of those remote partners. 01/11/2022, Bing Li
	private Map<String, PublicCrypto> publicCryptos;
	// The collection is used to map the peer key to the session key, which is used to retrieve the partner's public key. 01/11/2022, Bing Li
	private Map<String, String> peerSessionKeys;
	private Map<String, PublicCrypto> signaturePublicKeys;

	/*
	 * The below properties define the constraints for ownership. 03/22/2022, Bing Li
	 */
	private boolean isPrivate;
	private Map<String, OwnerInfo> owners;
	private AtomicInteger ownerSize;
	
	private ServiceProvider()
	{
		this.tasks = new ConcurrentHashMap<String, ServerTask>();
//		this.tasks = new ConcurrentHashMap<String, MulticastTask>();
		this.symmetricCryptos = new ConcurrentHashMap<String, SymmetricCrypto>();
		this.publicCryptos = new ConcurrentHashMap<String, PublicCrypto>();
		this.ips = new ConcurrentHashMap<String, IPAddress>();
		this.ipPeers = new ConcurrentHashMap<String, String>();
		
		this.peerSessionKeys = new ConcurrentHashMap<String, String>();
		this.signaturePublicKeys = new ConcurrentHashMap<String, PublicCrypto>();
		this.isPrivate = false;
		this.owners = new ConcurrentHashMap<String, OwnerInfo>();
		this.ownerSize = new AtomicInteger(0);
	}
	
	private static ServiceProvider instance = new ServiceProvider();
	
	public static ServiceProvider CRY()
	{
		if (instance == null)
		{
			instance = new ServiceProvider();
			return instance;
		}
		else
		{
			return instance;
		}
	}

	/*
	 * The initialization is called only by Server. 03/21/2022, Bing Li
	 */
//	public void init(String serverKey, MulticastTask task)
	public void init(String serverKey, ServerTask task)
	{
		this.tasks.put(serverKey, task);
	}

	/*
	public void init(String hostPeerName, String serverKey, ServerTask task)
	{
		this.hostPeerName = hostPeerName;
		this.tasks.put(serverKey, task);
	}
	*/

	/*
	 * The initialization is called only by Peer. 03/21/2022, Bing Li
	 */
//	public void init(String hostPeerName, String serverKey, MulticastTask task, AsymmetricCrypto asymCrypto)
	public void init(String hostPeerName, String serverKey, ServerTask task, AsymmetricCrypto asymCrypto)
	{
		this.hostPeerName = hostPeerName;
//		log.info("serverKey for task = " + serverKey);
		this.tasks.put(serverKey, task);
		this.asymCrypto = asymCrypto;
	}
	
//	public void removeAsymPartner(SayAsymmetricByeNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, InvalidAlgorithmParameterException, ShortBufferException, SessionMismatchedException
	public void removeAsymPartner(String serverKey, SayAsymmetricByeNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, InvalidAlgorithmParameterException, ShortBufferException, SessionMismatchedException
	{
		if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
		{
//			SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
			AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
			log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
			AsymmetricBye bye = (AsymmetricBye)SymmetricCoder.decryptObject(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec());
			this.publicCryptos.remove(bye.getPublicCryptoSessionKey());
			this.signaturePublicKeys.remove(bye.getSignature());
			this.peerSessionKeys.remove(bye.getHostPeerKey());
			this.ips.remove(bye.getHostPeerName());
			IPAddress ip = this.ips.get(bye.getHostPeerName());
			if (ip != null)
			{
				this.ipPeers.remove(ip.getIPKey());
			}
			if (this.owners.containsKey(bye.getSignature()))
			{
				this.owners.remove(bye.getSignature());
				/*
				 * This is the first time to raise an event to notify the upper level about the lower level updates. This is a good design. 03/24/2022, Bing Li
				 */
				this.tasks.get(serverKey).processNotification(new OwnerLeaveNotification(bye.getHostPeerName()));
			}
		}
		else
		{
			log.info("Session mismatched!");
			throw new SessionMismatchedException("The session of asymmetric encrypted notification mismatched!");
		}
	}
	
	public void removeSymPartner(SaySymmetricByeNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException
	{
		SymmetricCrypto sc = this.symmetricCryptos.get(notification.getSessionKey());
		log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
		SymmetricBye bye = (SymmetricBye)SymmetricCoder.decryptObject(notification.getEncryptedData(), sc.getCipherKey(), sc.getIVKey(), sc.getCipherSpec());
		this.symmetricCryptos.remove(bye.getHostPeerKey());
		IPAddress ip = this.ips.get(bye.getHostPeerName());
		this.ips.remove(bye.getHostPeerName());
		if (ip != null)
		{
			this.ipPeers.remove(ip.getIPKey());
		}
	}

	public void setPrivate(boolean isPrivate)
	{
		this.isPrivate = isPrivate;
	}
	
	public void setOwnersSize(int size)
	{
		if (this.isPrivate)
		{
			this.ownerSize.set(size);
		}
	}
	
	public Collection<OwnerInfo> getOwners()
	{
		if (this.isPrivate)
		{
			return this.owners.values();
		}
		return null;
	}
	
	public void reset(AsymmetricCrypto asymCrypto)
	{
		this.asymCrypto = asymCrypto;
	}

	/*
	public boolean isOwnerSet()
	{
		return this.asymCrypto.isOwnerSet();
	}
	*/

	/*
	public void setOwner(OwnerInfo oi)
	{
		this.asymCrypto.setOwner(oi);
	}
	*/

	/*
	public OwnerInfo getOwner()
	{
		return this.asymCrypto.getOwner();
	}
	*/
	
	public boolean isPartnerExisted(String peerKey)
	{
		return this.peerSessionKeys.containsKey(peerKey);
	}
	
	public void setPublicCrypto(PublicCrypto crypto)
	{
//		log.info("crypto sessionKey = " + crypto.getSessionKey());
		this.publicCryptos.put(crypto.getSessionKey(), crypto);
//		this.publicCryptos.put(crypto.getPeerKey(), crypto);
	}
	
//	public PublicCrypto getPublicCrypto(String peerKey)
	/*
	public PublicCrypto getPublicCryptoByPeer(String peerKey)
	{
		
		return this.publicCryptos.get(sessionKey);
	}
	*/
	
	public Map<String, PublicCrypto> getPublicCryptos()
	{
		return this.publicCryptos;
	}

	public PublicCrypto getPublicCryptoByPeer(String peerKey)
	{
//		log.info("peerKey = " + peerKey);
		String sessionKey = this.peerSessionKeys.get(peerKey);
		if (sessionKey != null)
		{
			return this.publicCryptos.get(sessionKey);
		}
		else
		{
			log.info("sessionKey is NULL!");
		}
		return null;
	}
	
	public PublicCrypto getPublicCryptoBySession(String sessionKey)
	{
		return this.publicCryptos.get(sessionKey);
	}
	
	public String getAsymmetricSessionKey()
	{
		return this.asymCrypto.getSessionKey();
	}
	
	public String getAsymmetricAlgorithm()
	{
		return this.asymCrypto.getAsymAlgorithm();
	}
	
	public PrivateKey getPrivateKey()
	{
		return this.asymCrypto.getPrivateKey();
	}
	
	public PublicKey getPublicKey()
	{
		return this.asymCrypto.getPublicKey();
	}
	
	public String getSignatureAlgorithm()
	{
		return this.asymCrypto.getSignatureAlgorithm();
	}
	
	public String getSignature()
	{
		return this.asymCrypto.getSignature();
	}
	
	public void setSignature(String signature)
	{
		this.asymCrypto.setSignature(signature);
	}

	public IPAddress getIP(String peerName)
	{
		return this.ips.get(peerName);
	}
	
	public String getPartnerName(String ipKey)
	{
		return this.ipPeers.get(ipKey);
	}
	
	public void addIP(String peerName, IPAddress ip)
	{
		this.ips.put(peerName, ip);
		this.ipPeers.put(ip.getIPKey(), peerName);
	}
	
	public Collection<String> getAllPeerNames()
	{
		return this.ips.keySet();
	}

	/*
	private void addSession(Crypto crypto)
	{
		this.cryptos.put(crypto.getSessionKey(), crypto);
	}
	*/
	
	public boolean isSymPartnerInvited(String partnerKey)
	{
		return this.symmetricCryptos.containsKey(partnerKey);
	}
	
	public boolean isSymmetricKeyExisted(String partnerKey)
	{
		return this.symmetricCryptos.containsKey(partnerKey);
	}

//	public void retainSymmetricCrypto(String partnerKey, SymmetricCrypto symCrypto)
	public void retainSymmetricCrypto(SymmetricCrypto symCrypto)
	{
//		this.symmetricCryptos.put(symCrypto.getSessionKey(), symCrypto);
//		this.symmetricCryptos.put(partnerKey, symCrypto);
//		this.symmetricCryptos.put(symCrypto.getSourcePeerKey(), symCrypto);
		this.symmetricCryptos.put(symCrypto.getDestinationPeerKey(), symCrypto);
	}

	/*
	 * The sender invokes the method to get the shared key. The shared key is retrieved by the partner's key. 02/05/2022, Bing Li
	 */
	public SymmetricCrypto getSymmetricCrypto(String partnerKey)
	{
		return this.symmetricCryptos.get(partnerKey);
	}

	/*
	 * 
	 * The receiver invokes the method to retain the sender's shared key. The shared key is retrieved by the session key. 02/05/2022, Bing Li
	 */
	public SymmetricCryptoSessionResponse retainSymmetricCrypto(SymmetricCryptoSessionRequest request)
	{
//		this.symmetricCryptos.put(request.getCrypto().getSessionKey(), request.getCrypto());
		this.symmetricCryptos.put(request.getCrypto().getSourcePeerKey(), request.getCrypto());
//		this.symmetricCryptos.put(request.getCrypto().getPeerKey(), request.getCrypto());
		return new SymmetricCryptoSessionResponse(true);
	}

	/*
	public void processNotification(String serverKey, ServerMessage notification) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			this.tasks.get(serverKey).processNotification(notification);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	*/

	public void processNotification(String serverKey, Notification notification) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
//			log.info("Before processing service notifications ...");
			this.tasks.get(serverKey).processNotification(notification);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	public void processMulticastNotification(String serverKey, MulticastNotification notification) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			((MulticastTask)this.tasks.get(serverKey)).processNotification(notification);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public void processMulticastRequest(String serverKey, MulticastRequest notification) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			((MulticastTask)this.tasks.get(serverKey)).processRequest(notification);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	public void processMulticastResponse(String serverKey, MulticastResponse notification) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			((MulticastTask)this.tasks.get(serverKey)).processNotification(notification);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	public ServerMessage processRequest(String serverKey, Request request) throws NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			return this.tasks.get(serverKey).processRequest(request);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	public void processSymmetricNotification(String serverKey, EncryptedNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			SymmetricCrypto sc = this.symmetricCryptos.get(notification.getSessionKey());
			log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
			this.tasks.get(serverKey).processNotification(SymmetricCoder.decryptNotification(notification.getEncryptedData(), sc.getCipherKey(), sc.getIVKey(), sc.getCipherSpec()));
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public void processSymmetricNotification(String serverKey, SymmetricPrimitiveNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			SymmetricCrypto sc = this.symmetricCryptos.get(notification.getSessionKey());
			log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
			this.processPrimitive(serverKey, SymmetricCoder.decryptMessage(notification.getEncryptedData(), sc.getCipherKey(), sc.getIVKey(), sc.getCipherSpec()));
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public EncryptedResponse processSymmetricRequest(String serverKey, EncryptedRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, NonPublicMachineException
	{
		if (!this.isPrivate)
		{
			SymmetricCrypto c = this.symmetricCryptos.get(request.getSessionKey());
			log.info("Received Encrypted Request: " + Hex.toHexString(request.getEncryptedData()));
//			return this.tasks.get(serverKey).processRequest(c, Coder.decryptRequest(request.getEncryptedData(), c.getCipherKey(), c.getIVKey(), c.getCipherApproach()));
			ServerMessage response = this.tasks.get(serverKey).processRequest(SymmetricCoder.decryptRequest(request.getEncryptedData(), c.getCipherKey(), c.getIVKey(), c.getCipherSpec()));
			byte[] resData = SymmetricCoder.encryptResponse(response, c.getCipherKey(), c.getIVKey(), c.getCipherSpec());
			log.info("Encrypted Response: " + Hex.toHexString(resData));
			return new EncryptedResponse(CryAppID.SYMMETRIC_ENCRYPTED_RESPONSE, resData);
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	public boolean isAsymPartnerInvited(String peerKey)
	{
		return this.peerSessionKeys.containsKey(peerKey);
	}

	public PublicCryptoSessionResponse retainPublicCrypto(PublicCryptoSessionRequest request) throws InvalidKeyException, NoSuchAlgorithmException, SignatureException, IOException
	{
		log.info(request.getHostPeerName() + "'s public key received!");
//		log.info("peerKey = " + request.getPublicCrypto().getHostPeerKey());
//		this.asymCrypto.setPublicCrypto(request.getPublicCrypto());
		this.setPublicCrypto(request.getPublicCrypto());
		this.peerSessionKeys.put(request.getPublicCrypto().getHostPeerKey(), request.getPublicCrypto().getSessionKey());
		if (request.getPublicCrypto().getSignature() != null)
		{
			/*
			 * It is not reasonable to make a judgment here since the signed interactions are performed after the public cryptography information is exchanged. 02/18/2022, Bing Li
			 */
			if (this.isSignatureTrusted(request.getPublicCrypto().getSignature(), request.getEncryptedSignature(), true))
			{
				this.signaturePublicKeys.put(request.getPublicCrypto().getSignature(), request.getPublicCrypto());
				return new PublicCryptoSessionResponse(this.hostPeerName, new PublicCrypto(ServiceProvider.CRY().getAsymmetricSessionKey(), PeerContainer.getPeerKey(this.hostPeerName), ServiceProvider.CRY().getAsymmetricAlgorithm(), ServiceProvider.CRY().getPublicKey(), ServiceProvider.CRY().getSignatureAlgorithm(), ServiceProvider.CRY().getSignature()), true);
			}
			else
			{
				return new PublicCryptoSessionResponse(this.hostPeerName, new PublicCrypto(ServiceProvider.CRY().getAsymmetricSessionKey(), PeerContainer.getPeerKey(this.hostPeerName), ServiceProvider.CRY().getAsymmetricAlgorithm(), ServiceProvider.CRY().getPublicKey(), ServiceProvider.CRY().getSignatureAlgorithm(), ServiceProvider.CRY().getSignature()), false);
			}
		}
		else
		{
			return new PublicCryptoSessionResponse(this.hostPeerName, new PublicCrypto(ServiceProvider.CRY().getAsymmetricSessionKey(), PeerContainer.getPeerKey(this.hostPeerName), ServiceProvider.CRY().getAsymmetricAlgorithm(), ServiceProvider.CRY().getPublicKey()), true);
		}
	}
	
	/*
	 * The method is invoked only when the partner is trusted only such that it is not necessary to verify. 01/15/2022, Bing Li
	 */
	public void retainPublicCrypto(PublicCrypto pc)
	{
//		log.info("PC's hostPeerKey = " + pc.getHostPeerKey());
		this.setPublicCrypto(pc);
		this.peerSessionKeys.put(pc.getHostPeerKey(), pc.getSessionKey());
		this.signaturePublicKeys.put(pc.getSignature(), pc);
	}

//	public void processAsymmetricNotification(String serverKey, EncryptedNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException
	public void processAsymmetricNotification(String serverKey, AsymmetricEncryptedNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
//				this.tasks.get(serverKey).processNotification(AsymmetricCoder.decrypt(notification.getEncryptedData(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey()));
				this.tasks.get(serverKey).processNotification(SymmetricCoder.decryptNotification(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of asymmetric encrypted notification mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public void processAsymmetricNotification(String serverKey, AsymmetricPrimitiveNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
				this.processPrimitive(serverKey, SymmetricCoder.decryptMessage(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of asymmetric encrypted notification mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	/*
	public boolean isOwner(String owner, Notification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException
	{
		SignedAsymmetricEncryptedNotification signedNotification = (SignedAsymmetricEncryptedNotification)notification;
		if (this.asymCrypto.getSessionKey().equals(signedNotification.getSessionKey()))
		{
			SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(signedNotification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
			PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
			if (publicKey != null)
			{
				if (this.isSignatureTrusted(signedNotification.getSignature(), signedNotification.getEncryptedSignature(), false))
				{
					if (signedNotification.getSignature().equals(owner))
					{
						return true;
					}
				}
			}
		}
		return false;
	}
	*/

	public void processAsymmetricNotification(String serverKey, SignedAsymmetricEncryptedNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
//			log.info("notification sessionKey = " + notification.getSessionKey());
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
//					if (AsymmetricCoder.verify(publicKey.getSignatureAlgorithm(), publicKey.getPublicKey(), publicKey.getSignature(), notification.getEncryptedSignature()))
					if (this.isSignatureTrusted(notification.getSignature(), notification.getEncryptedSignature(), false))
					{
						/*
						if (notification.isOwnerRequired())
						{
							if (this.owners.containsKey(notification.getSessionKey()))
							{
								if (!notification.getCorrectOwnerName().equals(this.owners.get(notification.getSessionKey()).getOwnerName()) || !notification.getSignature().equals(this.owners.get(notification.getSessionKey()).getSignature()))
								{
									log.info("Someone is cheating as " + notification.getCorrectOwnerName());
									throw new OwnerCheatingException(notification.getCorrectOwnerName());
								}
							}
						}
						*/
						log.info(publicKey.getSignature() + " is notifying to you!");
						log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
						this.tasks.get(serverKey).processNotification(SymmetricCoder.decryptNotification(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of signed asymmetric encrypted notification mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public void processAsymmetricNotification(String serverKey, SignedPrimitiveNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
					if (this.isSignatureTrusted(notification.getSignature(), notification.getEncryptedSignature(), false))
					{
						log.info(publicKey.getSignature() + " is notifying to you!");
						log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
						this.processPrimitive(serverKey, SymmetricCoder.decryptMessage(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of signed asymmetric encrypted notification mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}

	public void processAsymmetricNotification(String serverKey, PrivateNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, OwnerCheatingException, NonPrivateMachineException, SessionMismatchedException, MachineNotOwnedException
	{
		if (this.isPrivate)
		{
//			log.info("notification sessionKey = " + notification.getSessionKey());
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
					if (this.isSignatureTrusted(notification.getSignature(), notification.getEncryptedSignature(), false))
					{
//						if (this.owners.containsKey(notification.getSessionKey()))
						if (this.owners.containsKey(notification.getSignature()))
						{
							log.info("owner = " + this.owners.get(notification.getSignature()));
							log.info("notification's ownerName = " + notification.getOwnerName());
							log.info("notification's signature = " + notification.getSignature());
//							if (!notification.getOwnerName().equals(this.owners.get(notification.getSessionKey()).getOwnerName()) || !notification.getSignature().equals(this.owners.get(notification.getSessionKey()).getSignature()))
							if (!notification.getOwnerName().equals(this.owners.get(notification.getSignature()).getOwnerName()) || !notification.getSignature().equals(this.owners.get(notification.getSignature()).getSignature()))
							{
								log.info("Someone is cheating as " + notification.getOwnerName());
								throw new OwnerCheatingException(notification.getOwnerName());
							}
							log.info(publicKey.getSignature() + " is notifying to you!");
							log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
							this.tasks.get(serverKey).processNotification(SymmetricCoder.decryptNotification(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
						}
						else
						{
							throw new MachineNotOwnedException(publicKey.getSignature());
						}
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of private notification mismatched!");
			}
		}
		else
		{
			throw new NonPrivateMachineException("The machine is non-private!");
		}
	}

	public void processAsymmetricNotification(String serverKey, PrivatePrimitiveNotification notification) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, OwnerCheatingException, NonPrivateMachineException, SessionMismatchedException, MachineNotOwnedException
	{
		if (this.isPrivate)
		{
			if (this.asymCrypto.getSessionKey().equals(notification.getSessionKey()))
			{
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(notification.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
					if (this.isSignatureTrusted(notification.getSignature(), notification.getEncryptedSignature(), false))
					{
						if (this.owners.containsKey(notification.getSignature()))
						{
							log.info("owner = " + this.owners.get(notification.getSignature()));
							log.info("notification's ownerName = " + notification.getOwnerName());
							log.info("notification's signature = " + notification.getSignature());
							if (!notification.getOwnerName().equals(this.owners.get(notification.getSignature()).getOwnerName()) || !notification.getSignature().equals(this.owners.get(notification.getSignature()).getSignature()))
							{
								log.info("Someone is cheating as " + notification.getOwnerName());
								throw new OwnerCheatingException(notification.getOwnerName());
							}
							log.info(publicKey.getSignature() + " is notifying to you!");
							log.info("Received Encrypted Notification: " + Hex.toHexString(notification.getEncryptedData()));
							this.processPrimitive(serverKey, SymmetricCoder.decryptMessage(notification.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
						}
						else
						{
							throw new MachineNotOwnedException(publicKey.getSignature());
						}
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of private notification mismatched!");
			}
		}
		else
		{
			throw new NonPrivateMachineException("The machine is non-private!");
		}
	}
	
//	public EncryptedResponse processAsymmetricRequest(String serverKey, EncryptedRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException
	public AsymmetricEncryptedResponse processAsymmetricRequest(String serverKey, AsymmetricEncryptedRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, PublicKeyUnavailableException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
			if (request.getSessionKey().equals(this.asymCrypto.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				log.info("Received Encrypted Request: " + Hex.toHexString(request.getEncryptedData()));
//				ServerMessage response = this.tasks.get(serverKey).processRequest(AsymmetricCoder.decryptRequest(request.getEncryptedData(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey()));
				ServerMessage response = this.tasks.get(serverKey).processRequest(SymmetricCoder.decryptRequest(request.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
//				PublicCrypto pc = this.asymCrypto.getPublicCrypto(request.getSessionKey());
//				PublicCrypto pc = this.getPublicCryptoBySession(request.getSessionKey());
				PublicCrypto pc = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (pc != null)
				{
//					SymmetricCrypto nscrypto = SymmetricCoder.generateCrypto(this.asymCrypto.getSymCipherAlgorithm(), this.asymCrypto.getSymCipherSpec(), this.asymCrypto.getCipherKeyLength(), this.asymCrypto.getIVKeyLength());
					SymmetricCrypto nscrypto = SymmetricCoder.generateCrypto(this.asymCrypto.getSymCipherAlgorithm(), this.asymCrypto.getSymCipherSpec(), this.asymCrypto.getCipherKeyLength(), this.asymCrypto.getIVKeyLength());
//					byte[] resData = AsymmetricCoder.encryptResponse(response, pc.getAlgorithm(), pc.getPublicKey());
					byte[] resData = SymmetricCoder.encryptResponse(response, nscrypto.getCipherKey(), nscrypto.getIVKey(), nscrypto.getCipherSpec());
					byte[] enNScryptoData = AsymmetricCoder.encrypt(nscrypto, pc.getAsymAlgorithm(), pc.getPublicKey());
					log.info("Encrypted Response: " + Hex.toHexString(resData));
					return new AsymmetricEncryptedResponse(resData, enNScryptoData);
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!!");
				throw new SessionMismatchedException("The session of asymmetric encrypted notification mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is non-public!");
		}
	}
	
	/*
	public boolean isOwner(String owner, SignedAsymmetricEncryptedRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException
	{
//		SignedAsymmetricEncryptedRequest signedRequest = (SignedAsymmetricEncryptedRequest)request;
		if (request.getSessionKey().equals(this.asymCrypto.getSessionKey()))
		{
			SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
			PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
			if (publicKey != null)
			{
				if (this.isSignatureTrusted(request.getSignature(), request.getEncryptedSignature(), false))
				{
					if (request.getSignature().equals(owner))
					{
						return true;
					}
				}
			}
		}
		return false;
	}
	*/

//	public OwnershipResponse setOwner(OwnershipRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPrivateMachineException, SessionMismatchedException
	public OwnershipResponse setOwner(String serverKey, OwnershipRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPrivateMachineException, SessionMismatchedException
	{
		if (this.isPrivate)
		{
			if (request.getSessionKey().equals(this.asymCrypto.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
					if (this.isSignatureTrusted(request.getSignature(), request.getEncryptedSignature(), false))
					{
						log.info(publicKey.getSignature() + " is requesting to you!");
						log.info("Received Encrypted Request: " + Hex.toHexString(request.getEncryptedData()));
						OwnerInfo oi = (OwnerInfo)SymmetricCoder.decryptObject(request.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec());
//						boolean isSucceeded;
						/*
						if (!this.asymCrypto.isOwnerSet())
						{
							this.asymCrypto.setOwner(oi);
							isSucceeded = true;
						}
						else
						{
							isSucceeded = false;
						}
						*/
						AllOwners aos;
						if (this.owners.size() < this.ownerSize.get())
						{
							aos = new AllOwners(this.owners.values(), true);
//							this.owners.put(oi.getSessionKey(), oi);
							this.owners.put(oi.getSignature(), oi);
//							isSucceeded = true;
							
							/*
							 * This is the first time to raise an event to notify the upper level about the lower level updates. This is a good design. 03/24/2022, Bing Li
							 */
							this.tasks.get(serverKey).processNotification(new OwnerJoinNotification(oi.getOwnerName()));
						}
						else
						{
							aos = new AllOwners(false);
//							isSucceeded = false;
							log.info("Owners exceed the upper limit!");
						}

						SymmetricCrypto nscrypto = SymmetricCoder.generateCrypto(this.asymCrypto.getSymCipherAlgorithm(), this.asymCrypto.getSymCipherSpec(), this.asymCrypto.getCipherKeyLength(), this.asymCrypto.getIVKeyLength());
//						AllOwners aos = new AllOwners(this.owners.keySet(), isSucceeded);
//						byte[] resData = SymmetricCoder.encryptObject(isSucceeded, nscrypto.getCipherKey(), nscrypto.getIVKey(), nscrypto.getCipherSpec());
						byte[] resData = SymmetricCoder.encryptObject(aos, nscrypto.getCipherKey(), nscrypto.getIVKey(), nscrypto.getCipherSpec());
						byte[] enNScryptoData = AsymmetricCoder.encrypt(nscrypto, publicKey.getAsymAlgorithm(), publicKey.getPublicKey());
						byte[] signedInfo = AsymmetricCoder.sign(ServiceProvider.CRY().getSignatureAlgorithm(), ServiceProvider.CRY().getPrivateKey(), ServiceProvider.CRY().getSignature());
						log.info("Encrypted Response: " + Hex.toHexString(resData));
						return new OwnershipResponse(resData, enNScryptoData, ServiceProvider.CRY().getSignature(), signedInfo);
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!!");
				throw new SessionMismatchedException("The session of ownership request mismatched!");
			}
		}
		else
		{
			throw new NonPrivateMachineException("The machine is non-private!");
		}
	}

	public SignedAsymmetricEncryptedResponse processAsymmetricRequest(String serverKey, SignedAsymmetricEncryptedRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPublicMachineException, SessionMismatchedException
	{
		if (!this.isPrivate)
		{
			if (request.getSessionKey().equals(this.asymCrypto.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
//					if (AsymmetricCoder.verify(publicKey.getSignatureAlgorithm(), publicKey.getPublicKey(), publicKey.getSignature(), request.getEncryptedSignature()))
					if (this.isSignatureTrusted(request.getSignature(), request.getEncryptedSignature(), false))
					{
						/*
						if (request.isOwnerRequired())
						{
							if (this.owners.containsKey(request.getSessionKey()))
							{
								log.info("Owner = " + this.owners.get(request.getSessionKey()).getOwnerName() + ", Owner@request = " + request.getOwnerName());
								if (!request.getOwnerName().equals(this.owners.get(request.getSessionKey()).getOwnerName()) || !request.getSignature().equals(this.owners.get(request.getSessionKey()).getSignature()))
								{
									return new SignedAsymmetricEncryptedResponse(request.getOwnerName());
								}
							}
						}
						*/
						log.info(publicKey.getSignature() + " is requesting to you!");
						log.info("Received Encrypted Request: " + Hex.toHexString(request.getEncryptedData()));
						ServerMessage response = this.tasks.get(serverKey).processRequest(SymmetricCoder.decryptRequest(request.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
						SymmetricCrypto nscrypto = SymmetricCoder.generateCrypto(this.asymCrypto.getSymCipherAlgorithm(), this.asymCrypto.getSymCipherSpec(), this.asymCrypto.getCipherKeyLength(), this.asymCrypto.getIVKeyLength());
						byte[] resData = SymmetricCoder.encryptResponse(response, nscrypto.getCipherKey(), nscrypto.getIVKey(), nscrypto.getCipherSpec());
						byte[] enNScryptoData = AsymmetricCoder.encrypt(nscrypto, publicKey.getAsymAlgorithm(), publicKey.getPublicKey());
						byte[] signedInfo = AsymmetricCoder.sign(ServiceProvider.CRY().getSignatureAlgorithm(), ServiceProvider.CRY().getPrivateKey(), ServiceProvider.CRY().getSignature());
						log.info("Encrypted Response: " + Hex.toHexString(resData));
						return new SignedAsymmetricEncryptedResponse(resData, enNScryptoData, ServiceProvider.CRY().getSignature(), signedInfo);
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!");
				throw new SessionMismatchedException("The session of signed asymmetric encrypted request mismatched!");
			}
		}
		else
		{
			throw new NonPublicMachineException("The machine is a non-public!");
		}
	}

	public PrivateResponse processAsymmetricRequest(String serverKey, PrivateRequest request) throws InvalidKeyException, NoSuchAlgorithmException, NoSuchPaddingException, InvalidAlgorithmParameterException, ShortBufferException, IllegalBlockSizeException, BadPaddingException, ClassNotFoundException, IOException, SignatureException, CheatingException, PublicKeyUnavailableException, NonPrivateMachineException, SessionMismatchedException, MachineNotOwnedException, OwnerCheatingException
	{
		if (this.isPrivate)
		{
			if (request.getSessionKey().equals(this.asymCrypto.getSessionKey()))
			{
//				SymmetricCrypto scrypto = (SymmetricCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				AsymCompCrypto scrypto = (AsymCompCrypto)AsymmetricCoder.decrypt(request.getEncryptedSymCrypto(), this.asymCrypto.getAsymAlgorithm(), this.asymCrypto.getPrivateKey());
				PublicCrypto publicKey = this.getPublicCryptoByPeer(scrypto.getPeerKey());
				if (publicKey != null)
				{
//					if (AsymmetricCoder.verify(publicKey.getSignatureAlgorithm(), publicKey.getPublicKey(), publicKey.getSignature(), request.getEncryptedSignature()))
					if (this.isSignatureTrusted(request.getSignature(), request.getEncryptedSignature(), false))
					{
//						if (this.owners.containsKey(request.getSessionKey()))
						if (this.owners.containsKey(request.getSignature()))
						{
//							log.info("Owner = " + this.owners.get(request.getSessionKey()).getOwnerName() + ", Owner@request = " + request.getOwnerName());
							log.info("owner = " + this.owners.get(request.getSignature()));
							log.info("request ownerName = " + request.getOwnerName());
							log.info("request signature = " + request.getSignature());
//							if (!request.getOwnerName().equals(this.owners.get(request.getSessionKey()).getOwnerName()) || !request.getSignature().equals(this.owners.get(request.getSessionKey()).getSignature()))
							if (!request.getOwnerName().equals(this.owners.get(request.getSignature()).getOwnerName()) || !request.getSignature().equals(this.owners.get(request.getSignature()).getSignature()))
							{
//								return new PrivateResponse(request.getOwnerName());
								throw new OwnerCheatingException(request.getOwnerName());
							}
							log.info(publicKey.getSignature() + " is requesting to you!");
							log.info("Received Encrypted Request: " + Hex.toHexString(request.getEncryptedData()));
							ServerMessage response = this.tasks.get(serverKey).processRequest(SymmetricCoder.decryptRequest(request.getEncryptedData(), scrypto.getCipherKey(), scrypto.getIVKey(), scrypto.getCipherSpec()));
							SymmetricCrypto nscrypto = SymmetricCoder.generateCrypto(this.asymCrypto.getSymCipherAlgorithm(), this.asymCrypto.getSymCipherSpec(), this.asymCrypto.getCipherKeyLength(), this.asymCrypto.getIVKeyLength());
							byte[] resData = SymmetricCoder.encryptResponse(response, nscrypto.getCipherKey(), nscrypto.getIVKey(), nscrypto.getCipherSpec());
							byte[] enNScryptoData = AsymmetricCoder.encrypt(nscrypto, publicKey.getAsymAlgorithm(), publicKey.getPublicKey());
							byte[] signedInfo = AsymmetricCoder.sign(ServiceProvider.CRY().getSignatureAlgorithm(), ServiceProvider.CRY().getPrivateKey(), ServiceProvider.CRY().getSignature());
							log.info("Encrypted Response: " + Hex.toHexString(resData));
							return new PrivateResponse(resData, enNScryptoData, ServiceProvider.CRY().getSignature(), signedInfo);
						}
						else
						{
							throw new MachineNotOwnedException(publicKey.getSignature());
						}
					}
					else
					{
						log.info("Someone is cheating as " + publicKey.getSignature());
						throw new CheatingException(publicKey.getSignature());
					}
				}
				else
				{
					log.info("Public key is not found!");
					throw new PublicKeyUnavailableException(scrypto.getPeerKey());
				}
			}
			else
			{
				log.info("Session mismatched!!");
				throw new SessionMismatchedException("The session of private request mismatched!");
			}
		}
		else
		{
			throw new NonPrivateMachineException("The machine is non-private!");
		}
	}

	public boolean isSignatureTrusted(String signature, byte[] encryptedSignature, boolean isInit) throws InvalidKeyException, NoSuchAlgorithmException, SignatureException, IOException
	{
		PublicCrypto existingPC = this.signaturePublicKeys.get(signature);
		if (existingPC != null)
		{
			log.info("Signature: " + signature + " is being verified ...");
			if (!AsymmetricCoder.verify(existingPC.getSignatureAlgorithm(), existingPC.getPublicKey(), existingPC.getSignature(), encryptedSignature))
			{
				log.info("Someone is pretending to be " + existingPC.getSignature());
				return false;
			}
			else
			{
				log.info("A trusted partner, " + signature + ", is starting to interact with you!");
				return true;
			}
		}
		else
		{
			if (!isInit)
			{
				log.info("Signature: " + signature + "'s public key is not found ...");
			}
		}
		if (isInit)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	
	private void processPrimitive(String serverKey, ServerMessage message)
	{
		switch (message.getType())
		{
			case MulticastMessageType.MULTICAST_RESPONSE:
				log.info("MULTICAST_RESPONSE received @" + Calendar.getInstance().getTime());
				((MulticastTask)this.tasks.get(serverKey)).processNotification((MulticastResponse)message);
				break;
				
			case MulticastMessageType.MULTICAST_NOTIFICATION:
				log.info("MULTICAST_NOTIFICATION received @" + Calendar.getInstance().getTime());
				((MulticastTask)this.tasks.get(serverKey)).processNotification((MulticastNotification)message);
				break;
				
			case MulticastMessageType.MULTICAST_REQUEST:
				log.info("MULTICAST_NOTIFICATION received @" + Calendar.getInstance().getTime());
				((MulticastTask)this.tasks.get(serverKey)).processRequest((MulticastRequest)message);
				break;
		}
	}
}
