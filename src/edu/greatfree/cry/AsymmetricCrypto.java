package edu.greatfree.cry;

import java.security.PrivateKey;
import java.security.PublicKey;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * 
 * @author libing
 * 
 * 01/11/2022, Bing i
 *
 */
public final class AsymmetricCrypto
{
	// The key is used to verify whether the keys are the current valid ones. 01/11/2022, Bing Li
	private String sessionKey;
	private String asymAlgorithm;
//	private String dsaAlgorithm;
	private PublicKey publicKey;
	private PrivateKey privateKey;
	
	// The public keys are generated by remote partners. Using them, the messages to those partners can be encrypted. The key of the map is the session key of the AsymmetricCrypto of those remote partners. 01/11/2022, Bing Li
//	private Map<String, PublicCrypto> publicCryptos;
	
//	private SymmetricCrypto symCrypto;
	
	private String symCipherAlgorithm;
	private String symCipherSpec;
	private int symCipherKeyLength;
	private int symIVKeyLength;

	private String signatureAlgorithm;
	private String signature;

	/*
	 * The owner of a machine does not depend on the asymmetric algorithm. So it is not proper to place the owner within the class. 03/21/2022, Bing Li
	 */
//	private OwnerInfo owner;
//	private Map<String, OwnerInfo> ownerInfos;
//	private AtomicInteger ownerSize;

	private ReentrantReadWriteLock lock;

//	public AsymmetricCrypto(String sessionKey, String algorithm, PublicKey publicKey, PrivateKey privateKey, SymmetricCrypto symCrypto)
	public AsymmetricCrypto(String sessionKey, String asymAlgorithm, PublicKey publicKey, PrivateKey privateKey, String symCipherAlgorithm, String symCipherSpec, int symCipherKeyLength, int symIVKeyLength)
	{
		this.sessionKey = sessionKey;
		this.asymAlgorithm = asymAlgorithm;
		this.publicKey = publicKey;
		this.privateKey = privateKey;
//		this.publicCryptos = new ConcurrentHashMap<String, PublicCrypto>();
//		this.symCrypto = symCrypto;
		this.symCipherAlgorithm = symCipherAlgorithm;
		this.symCipherSpec = symCipherSpec;
		this.symCipherKeyLength = symCipherKeyLength;
		this.symIVKeyLength = symIVKeyLength;
		this.lock = new ReentrantReadWriteLock();
		this.signature = null;
//		this.owner = null;
	}

//	public AsymmetricCrypto(String sessionKey, String dsaAlgorithm, String asymAlgorithm, PublicKey publicKey, PrivateKey privateKey, String symCipherAlgorithm, String symCipherSpec, int symCipherKeyLength, int symIVKeyLength, String signature)
	public AsymmetricCrypto(String sessionKey, String asymAlgorithm, PublicKey publicKey, PrivateKey privateKey, String symCipherAlgorithm, String symCipherSpec, int symCipherKeyLength, int symIVKeyLength, String signatureAlgorithm, String signature)
	{
		this.sessionKey = sessionKey;
//		this.dsaAlgorithm = dsaAlgorithm;
		this.asymAlgorithm = asymAlgorithm;
		this.publicKey = publicKey;
		this.privateKey = privateKey;
//		this.publicCryptos = new ConcurrentHashMap<String, PublicCrypto>();
//		this.symCrypto = symCrypto;
		this.symCipherAlgorithm = symCipherAlgorithm;
		this.symCipherSpec = symCipherSpec;
		this.symCipherKeyLength = symCipherKeyLength;
		this.symIVKeyLength = symIVKeyLength;
		this.lock = new ReentrantReadWriteLock();
		this.signatureAlgorithm = signatureAlgorithm;
		this.signature = signature;
//		this.owner = null;
	}

//	public AsymmetricCrypto(String sessionKey, String algorithm, PublicKey publicKey, PrivateKey privateKey, Map<String, PublicCrypto> publicCryptos, SymmetricCrypto symCrypto)
	/*
	public AsymmetricCrypto(String sessionKey, String asymAlgorithm, PublicKey publicKey, PrivateKey privateKey, Map<String, PublicCrypto> publicCryptos, String symCipherAlgorithm, String symCipherSpec, int symCipherKeyLength, int symIVKeyLength)
	{
		this.sessionKey = sessionKey;
		this.asymAlgorithm = asymAlgorithm;
		this.publicKey = publicKey;
		this.privateKey = privateKey;
		this.publicCryptos = publicCryptos;
		this.lock = new ReentrantReadWriteLock();
//		this.symCrypto = symCrypto;
		this.symCipherAlgorithm = symCipherAlgorithm;
		this.symCipherSpec = symCipherSpec;
		this.symCipherKeyLength = symCipherKeyLength;
		this.symIVKeyLength = symIVKeyLength;
	}
	*/

	public String getSessionKey()
	{
		this.lock.readLock().lock();
		try
		{
			return this.sessionKey;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}

	/*
	public String getDSAAlgorithm()
	{
		this.lock.readLock().lock();
		try
		{
			return this.dsaAlgorithm;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	*/
	
	public String getAsymAlgorithm()
	{
		this.lock.readLock().lock();
		try
		{
			return this.asymAlgorithm;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public PublicKey getPublicKey()
	{
		this.lock.readLock().lock();
		try
		{
			return this.publicKey;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public void setPublicKey(PublicKey publicKey)
	{
		this.lock.writeLock().lock();
		this.publicKey = publicKey;
		this.lock.writeLock().unlock();
	}
	
	public PrivateKey getPrivateKey()
	{
		this.lock.readLock().lock();
		try
		{
			return this.privateKey;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public void setPrivateKey(PrivateKey privateKey)
	{
		this.lock.writeLock().lock();
		this.privateKey = privateKey;
		this.lock.writeLock().unlock();
	}

	/*
	public SymmetricCrypto getSymCrypto()
	{
		this.lock.readLock().lock();
		try
		{
			return this.symCrypto;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public SecretKey getSymCipherKey()
	{
		this.lock.readLock().lock();
		try
		{
			return this.sy
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	*/
	
	public String getSymCipherAlgorithm()
	{
		this.lock.readLock().lock();;
		try
		{
			return this.symCipherAlgorithm;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}

	public String getSymCipherSpec()
	{
		this.lock.readLock().lock();
		try
		{
			return this.symCipherSpec;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public int getCipherKeyLength()
	{
		this.lock.readLock().lock();
		try
		{
			return this.symCipherKeyLength;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public int getIVKeyLength()
	{
		this.lock.readLock().lock();
		try
		{
			return this.symIVKeyLength;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public String getSignatureAlgorithm()
	{
		this.lock.readLock().lock();
		try
		{
			return this.signatureAlgorithm;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public void setSignature(String signature)
	{
		this.lock.writeLock().lock();
		this.signature = signature;
		this.lock.writeLock().unlock();
	}
	
	public String getSignature()
	{
		this.lock.readLock().lock();
		try
		{
			return this.signature;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}

	/*
	public SecretKey getSymIVKey()
	{
		this.lock.readLock().lock();
		try
		{
			return this.symCrypto.getIVKey();
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	*/

	/*
	public boolean isOwnerSet()
	{
		this.lock.readLock().lock();
		try
		{
			return this.owner == null ? false : true;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	
	public void setOwner(OwnerInfo oi)
	{
		this.lock.writeLock().lock();
		this.owner = oi;
		this.lock.writeLock().unlock();
	}
	
	public OwnerInfo getOwner()
	{
		this.lock.readLock().lock();
		try
		{
			return this.owner;
		}
		finally
		{
			this.lock.readLock().unlock();
		}
	}
	*/
}
